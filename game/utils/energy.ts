import type { Ship, ShipSubsystems } from '../../types';

/**
 * Calculates the amount of energy restored by one dilithium crystal,
 * based on the ship's engine health. Scales from 5% to 100%.
 * @param ship The ship using the crystal.
 * @returns The amount of energy restored.
 */
function calculateEnergyPerCrystal(ship: Ship): number {
    const engineEfficiency = ship.subsystems.engines.maxHealth > 0 
        ? ship.subsystems.engines.health / ship.subsystems.engines.maxHealth 
        : 0;
    // New scaling: 5% at 0% health, 100% at 100% health.
    const restoredEnergyFraction = 0.05 + 0.95 * engineEfficiency;
    return ship.energy.max * restoredEnergyFraction;
}

/**
 * Applies consequential damage to a random subsystem after an emergency power transfer.
 * @param ship The ship to damage.
 * @param crystalsUsed The number of crystals used, which scales the damage.
 * @returns A log message about the damage, or null if no damage occurred.
 */
function applyConsequentialDamage(ship: Ship, crystalsUsed: number): string | null {
    // 25% chance of damage per crystal used.
    if (Math.random() > 0.25 * crystalsUsed) {
        return null;
    }
    
    const subsystems: (keyof ShipSubsystems)[] = ['weapons', 'engines', 'shields', 'transporter', 'pointDefense', 'computer', 'lifeSupport'];
    const functioningSubsystems = subsystems.filter(key => {
        const system = ship.subsystems[key];
        return system && system.maxHealth > 0 && system.health > 0;
    });

    if (functioningSubsystems.length === 0) {
        return null;
    }

    const randomSubsystemKey = functioningSubsystems[Math.floor(Math.random() * functioningSubsystems.length)];
    const targetSubsystem = ship.subsystems[randomSubsystemKey];
    // Damage scales with crystals used
    const damage = (5 + Math.floor(Math.random() * 6)) * crystalsUsed;
    targetSubsystem.health = Math.max(0, targetSubsystem.health - damage);
    
    return `WARNING: The emergency power transfer of ${crystalsUsed} crystal(s) caused ${damage} damage to the ${randomSubsystemKey} system!`;
}


/**
 * Consumes one dilithium crystal to provide an emergency energy boost for a specific action.
 * @param ship The ship using the crystal.
 * @returns An object containing the amount of energy restored and any log messages.
 */
export function useOneDilithiumCrystal(ship: Ship): { restoredEnergy: number, logs: string[] } {
    const logs: string[] = [];
    if (ship.dilithium.current <= 0) {
        return { restoredEnergy: 0, logs: ["No dilithium crystals available."] };
    }
    
    ship.dilithium.current--;
    const restoredEnergy = calculateEnergyPerCrystal(ship);
    ship.energy.current = Math.min(ship.energy.max, ship.energy.current + restoredEnergy);
    
    logs.push(`Consumed one dilithium crystal to restore ${Math.round(restoredEnergy)} energy.`);

    const damageLog = applyConsequentialDamage(ship, 1);
    if (damageLog) {
        logs.push(damageLog);
    }

    return { restoredEnergy, logs };
}

/**
 * At the end of a turn when a ship is out of power, consumes as many dilithium crystals
 * as needed to attempt a full recharge.
 * @param ship The ship to recharge.
 * @param turn The current game turn.
 * @returns An array of log messages generated by the process.
 */
export function handleFullRecharge(ship: Ship, turn: number): string[] {
    const logs: string[] = [];
    
    if (ship.dilithium.current <= 0) {
        if (ship.lifeSupportFailureTurn === null) {
            ship.lifeSupportFailureTurn = turn;
            logs.push(`CRITICAL: All power and dilithium reserves exhausted! Life support is switching to emergency batteries.`);
        }
        return logs;
    }
    
    const energyNeeded = ship.energy.max - ship.energy.current;
    if (energyNeeded <= 0) {
        return logs;
    }

    const energyPerCrystal = calculateEnergyPerCrystal(ship);

    // If efficiency is very low, add a message, but still proceed with multi-crystal logic.
    // Use 0.051 for floating point safety.
    if (energyPerCrystal <= (ship.energy.max * 0.051)) { 
        logs.push(`Engines are too damaged to effectively channel power from dilithium.`);
    }

    // This logic now runs for all cases where dilithium is available.
    // It will be a very large number if energyPerCrystal is small, which is fine.
    const crystalsToUse = Math.ceil(energyNeeded / energyPerCrystal);
    const crystalsAvailable = ship.dilithium.current;
    const crystalsToConsume = Math.min(crystalsToUse, crystalsAvailable);

    // Should not consume 0 crystals if some are available and needed.
    if (crystalsToConsume > 0) {
        ship.dilithium.current -= crystalsToConsume;
        const totalEnergyRestored = crystalsToConsume * energyPerCrystal;
        ship.energy.current = Math.min(ship.energy.max, ship.energy.current + totalEnergyRestored);

        logs.push(`Reserve power depleted! Consuming ${crystalsToConsume} dilithium crystal(s) to restore ${Math.round(totalEnergyRestored)} energy.`);

        const damageLog = applyConsequentialDamage(ship, crystalsToConsume);
        if (damageLog) {
            logs.push(damageLog);
        }
    }
    
    return logs;
}